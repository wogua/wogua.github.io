<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Alios PageIPC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/Alios PageIPC/" class="article-date">
  <time datetime="2018-05-17T16:00:00.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript学习/">Javascript学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/Alios PageIPC/">Alios PageIPC getRunningPages源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Alios App获取系统已经安装或者正在运行的Page或者Server可以通过PageManager或者PageImpl调用相应方法得到，下面以getRunningPages为例跟踪源码调用流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">framework\npm\caf2\src\page\PageManager.js</span><br><span class="line">getTopPage(callback) &#123;</span><br><span class="line">    this.page.instance.getTopPage(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this.page.instance实例为PageImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">framework\npm\pageapi\PageImpl.js</span><br><span class="line">getRunningPages(callback) &#123;</span><br><span class="line">    pipc.dpms.getRunningPages(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里pipc是framework\npm\pageapi\internal\PageIPC.js，先看看dpms是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get dpms() &#123;</span><br><span class="line">    return Impl.getImpl(this).firstDpmsProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Impl是PageIPC.js中的内部类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Impl &#123;</span><br><span class="line">    static getImpl(ipc) &#123;</span><br><span class="line">        return pu.getStoredObject(ipc, Impl);</span><br><span class="line">	&#125;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中pu是framework\npm\pageapi\internal\PageUtil.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static getStoredObject(obj, ImplClass) &#123;</span><br><span class="line">	……</span><br><span class="line">	map[realId] = new ImplClass(obj);</span><br><span class="line">	……</span><br><span class="line">	return map[realId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故实际上Impl. getImpl(ipc)返回的是new Impl(ipc);PageUtils只是将Impl实例缓存起来了（PageUtils 中的gStoredObjects 静态map），如果已经实例化的直接在缓存中取。  下面继续看Impl.getImpl(this).firstDpmsProxy;中的firstDpmsProxy；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get firstDpmsProxy() &#123;</span><br><span class="line">    if (this._dpmsProxy === undefined) &#123;</span><br><span class="line">        this._dpmsProxy = new DPMSProxy(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this._dpmsProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回DPMSProxy实例，DPMSProxy是PageIPC.js中的内部类；下面看DPMSProxy中的getRunningPages</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getRunningPages(callback) &#123;</span><br><span class="line">    var msg = this._interface.createMethodCallMessage(&quot;getRunningPages&quot;);</span><br><span class="line">    this._interface.sendMethodCallMessage(msg, (err, res) =&gt; &#123;</span><br><span class="line">        var pageList = [];</span><br><span class="line">        if (!err &amp;&amp; res) &#123;</span><br><span class="line">            var size = res.readInt32();</span><br><span class="line">            for (var i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                let pageInfo = JSON.parse(res.readString());</span><br><span class="line">                pageList.push(pageInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            res.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        this.callbackIfValid(callback, err, pageList);</span><br><span class="line">    &#125;, this._timeout, &quot;m&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上_interface是ubus通信接口，通过ubus通信调用目标进程getRunningPages方法并回调(err, res)=&gt;{},最终将返回结果解析并回调给callback;<br>为了了解PageIPC通过ubus和哪个进程在通信，我们继续跟ubus相关代码，下面是DPMSProxy构造方法中_interface的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(ipcImpl) &#123;</span><br><span class="line">    ……</span><br><span class="line">    this._ubus = new Ubus();</span><br><span class="line">    this._interface = this._ubus.createInterface(&quot;dpms.pagemanager.yunos.com&quot;,</span><br><span class="line">            &quot;/dpms/pagemanager/yunos/com&quot;,</span><br><span class="line">            &quot;dpms.pagemanager.yunos.com&quot;, false, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过ubus创建一个ubus实例，这个实例通过参数与具体的进程建立连接，通过查找dpms.pagemanager.yunos.com，找到这几个参数定义在framework\nativeservice\pagemgrd\dpms\src\ipc\MessageAdaptor.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const String DYNAMIC_PAGE_MANAGER_DBUS_SERVICE_NAME(&quot;dpms.pagemanager.yunos.com&quot;);</span><br><span class="line">const String DYNAMIC_PAGE_MANAGER_DBUS_INTERFACE_NAME(&quot;dpms.pagemanager.yunos.com&quot;);</span><br><span class="line">const String DYNAMIC_PAGE_MANAGER_DBUS_OBJECT_PATH(&quot;/dpms/pagemanager/yunos/com&quot;);</span><br></pre></td></tr></table></figure>
<p>然后我们看ubus.js中 createInterface方法：<br>ramework\npm\ubus\lib\ubus.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;String&#125; serviceName name of Service.</span><br><span class="line"> * @param &#123;String&#125; path path of ServiceObject.</span><br><span class="line"> * @param &#123;String&#125; interfaceName name of ServiceInterface.</span><br><span class="line"> * @param &#123;Boolean&#125; reverse whether to create a reverse channel after connected to service interface.</span><br><span class="line"> * @param &#123;Boolean&#125; awareLifecycle whether to enable death notificat, defauts to true</span><br><span class="line"> * @return &#123;Interface&#125;</span><br><span class="line"> */</span><br><span class="line">UBus.prototype.createInterface = function(serviceName, path, interfaceName, reverse,</span><br><span class="line">        awareLifecycle, shared) &#123;</span><br><span class="line">……</span><br><span class="line">iface._iface = _ubus.getInterface(serviceName, path, interfaceName, this.type,</span><br><span class="line">        reverse, awareLifecycle);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终是调用_ubus. getInterface，这里的_ubus初始化如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    _ubus = require(&quot;node_ubus.node&quot;);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    log.E(TAG, e);</span><br><span class="line">    _ubus = process.binding(&quot;ubus&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查找node_ubus.node得知其为编译出的二进制文件，而打包的地方在  framework\npm\ubus\src\ubus.cc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined(NODE_ADDON_BUILTIN)</span><br><span class="line">NODE_MODULE_CONTEXT_AWARE_BUILTIN(ubus, init);</span><br><span class="line">#else</span><br><span class="line">NODE_MODULE(node_ubus, init);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>Ubus.cc中定义了ubus的接口方法，如下是我们这里需要关注的几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_SET_METHOD(target, &quot;getInterface&quot;, GetInterface);</span><br><span class="line">NODE_SET_METHOD(target, &quot;createMethodCallMessage&quot;, CreateMethodCallMessage);</span><br><span class="line">NODE_SET_METHOD(target, &quot;sendMethodCallMessage&quot;, SendMethodCallMessage);</span><br></pre></td></tr></table></figure>
<p>GetInterface方法的具体实现在framework\npm\ubus\src\bus_proxy.cc<br>CreateMethodCallMessage方法的具体实现在framework\npm\ubus\src\bus_message.cc<br>SendMethodCallMessage方法的具体实现在framework\npm\ubus\src\bus_proxy.cc<br>framework\npm\ubus\src\bus_proxy.cc 中GetInterface创建BusProxy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void GetInterface(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">	……</span><br><span class="line">	SharedPtr&lt;BusProxy&gt; bus_proxy = BusProxy::createProxy(service_name, object_path, interface_name,</span><br><span class="line">            strcmp(type, &quot;kdbus&quot;) == 0 ? true : false, args[4]-&gt;BooleanValue(),</span><br><span class="line">            args[5]-&gt;BooleanValue(), env);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>framework\npm\ubus\src\bus_message.cc中CreateMethodCallMessage创建一个DMessage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void CreateMethodCallMessage(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">	……</span><br><span class="line">	SharedPtr&lt;DMessage&gt;* msg =</span><br><span class="line">            new SharedPtr&lt;DMessage&gt;((*proxy)-&gt;obtainMethodCallMessage(String(method)));</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>framework\npm\ubus\src\bus_proxy.cc中SendMethodCallMessage通过创建的BusProxy实例发送DMessage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void SendMethodCallMessage(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">	……</span><br><span class="line">	bool ret = (*proxy)-&gt;sendMethodCallMessage(*msg, callback_data, timeout);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next -&gt; framework\npm\ubus\src\bus_proxy.cc : sendMethodCallMessage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool BusProxy::sendMethodCallMessage(</span><br><span class="line">        SharedPtr&lt;DMessage&gt; msg, MethodCallbackData* callback_data, int timeout) &#123;</span><br><span class="line">    return sendMessageWithReply(msg, ReplyHandler(handleMethodCall, callback_data), timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next -&gt; framework\libs\base\dbus\DProxy.cpp : sendMessageWithReply</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool DProxy::sendMessageWithReply(const SharedPtr&lt;DMessage&gt;&amp; msg,</span><br><span class="line">        const ReplyHandler&amp; handler, int timeout) &#123;</span><br><span class="line">    return mConn-&gt;sendMessageWithReply(msg, handler, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next -&gt; framework\libs\base\dbus\KDBusConnection.cpp : sendMessageWithReply</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void KDBusConnection::sendMessageWithReply(……)&#123;</span><br><span class="line">……</span><br><span class="line">	int r = sd_bus_call_async(mConn, NULL, msg,</span><br><span class="line">                KDMessagePrivate::methodCallback, call, timeout);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sd_bus_call_async函数会调到三方ubus源码，alios中具体路径如下<br>third_party/libkdbus/libkdbus/sd-bus/sd-bus.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_public_ int sd_bus_call_async(……)&#123;</span><br><span class="line">	……</span><br><span class="line">_public_ int sd_bus_call_async(</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int bus_send_internal(……)&#123;</span><br><span class="line">	……</span><br><span class="line">	r = bus_write_message(bus, m, hint_sync_call, &amp;idx);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int bus_write_message(sd_bus *bus, sd_bus_message *m, bool hint_sync_call, size_t *idx) &#123;</span><br><span class="line">	……</span><br><span class="line">if (bus-&gt;is_kernel)</span><br><span class="line">        r = bus_kernel_write_message(bus, m, hint_sync_call);//通过kernel写数据</span><br><span class="line">else</span><br><span class="line">        r = bus_socket_write_message(bus, m, idx);//通过socket写数据传递消息</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next -&gt; third_party/libkdbus/ sd-bus/bus-socket.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int bus_socket_write_message(sd_bus *bus, sd_bus_message *m, size_t *idx) &#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dbus具体如何通信需要后面系统学习后再做分享，大致可以理解这里<code>bus_socket_write_message</code>写消息到KDbus设备，然后由kdbus将信息发到总线，目标进程首先要注册到dbus，然后就可以收到总线的消息.</p>
<p>现在我们直接看接收方，我们前面说的framework\nativeservice\pagemgrd\dpms\src\ipc\MessageAdaptor.cpp的handleMethodCall函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool MessageAdaptor::handleMethodCall(const SharedPtr&lt;DMessage&gt;&amp; msg) &#123;</span><br><span class="line">	……</span><br><span class="line">	DBUS_ON_MSG_VOID_REPLY(&quot;getRunningPages&quot;, onGetRunningPages)</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的getRunningPages调用映射到onGetRunningPages函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void MessageAdaptor::onGetRunningPages(const SharedPtr&lt;DMessage&gt;&amp; reply) &#123;</span><br><span class="line">    handler()-&gt;getRunningPages(reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的handler()在对应的.h文件中定义MessageAdaptor.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPtr&lt;DynamicPageManagerService&gt; handler();</span><br></pre></td></tr></table></figure>
<p>故handler()是DynamicPageManagerService实例<br>framework\nativeservice\pagemgrd\dpms\src\DynamicPageManagerService.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void DynamicPageManagerService::getRunningPages(const SharedPtr&lt;DMessage&gt;&amp; reply) &#123;</span><br><span class="line">    std::list&lt;DomainRecord*&gt; domainList;</span><br><span class="line">    dpmsFTY-&gt;getDomainManager()-&gt;getRunningDomains(&amp;domainList, USER_CURRENT);</span><br><span class="line">    std::list&lt;PageRecord*&gt; pageList;</span><br><span class="line">    for (DomainRecord* domain : domainList) &#123;</span><br><span class="line">        pageList.splice(pageList.end(), domain-&gt;getPageList());</span><br><span class="line">    &#125;</span><br><span class="line">    // skip not ready pages</span><br><span class="line">    pageList.remove_if([](PageRecord* page)&#123; return !page-&gt;isReady(); &#125;);</span><br><span class="line"></span><br><span class="line">    LOG_D(&quot;%s size: %d&quot;, __FUNCTION__, pageList.size());</span><br><span class="line">	// total size</span><br><span class="line">	//这里写数据对应PageIPC中getRunningPages的回调的读数据</span><br><span class="line">    reply-&gt;writeInt32(pageList.size());</span><br><span class="line">    for (PageRecord* page : pageList) &#123;</span><br><span class="line">        page-&gt;toMessage(reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是本地服务真正实现getRunningPages的地方，通过代码可以看出其逻辑是先getRunningDomains获取正在运行的Domains（类似Android中的Package），然遍历Domain中的Page，最后将所有这些Page返回。<br>看到DynamicPageManagerService中的PageRecord和DomainRecord是不是很熟悉的赶脚，自然联想到Android中的ActivityRecord，TaskRecord，ProcessRecord，详细的分析留待后续输出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/Alios PageIPC/" data-id="cjhulgd3t0004t5uikq8in6r7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Alios/">Alios</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PageIPC/">PageIPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/getRunningPages/">getRunningPages</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Javascript first getting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/Javascript first getting/" class="article-date">
  <time datetime="2018-05-17T16:00:00.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Javascript学习/">Javascript学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/Javascript first getting/">Javascript基础认知</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>此篇博客是我为同事讲解JavaScript基础的PPT。只有内容框架，详细的需要大家自行百度。</strong></p>
<h3 id="1-Javascript概要认识"><a href="#1-Javascript概要认识" class="headerlink" title="1. Javascript概要认识"></a>1. Javascript概要认识</h3><p>从Android转向Alios，Alios上层用JavaScript实现，学习JavaScript两个月，起初认为JavaScript是函数式语言，后来发现JavaScript也是面向对象的，另外JavaScript也无可厚非的是解释型语言，当然，它也是原型语言。but，作为函数式语言，它却不全是函数，真正的纯函数式语言“一切皆为函数”，包括字符，数字常量；而说到面向对象，JavaScript真的有点勉强，都是为了实现面向对象而面向对象；作为解释型语言，它又极力去做预编译优化。so，JavaScript到底是怎样一个存在。我们来一一探讨。</p>
<ul>
<li>解释型语言</li>
<li>函数式语言</li>
<li>面向对象</li>
<li>原型对象及原型链</li>
</ul>
<h3 id="2-Javascript——解释型语言"><a href="#2-Javascript——解释型语言" class="headerlink" title="2. Javascript——解释型语言"></a>2. Javascript——解释型语言</h3><p>我们首先明确下编译型语言和解释型语言的概念。</p>
<ul>
<li>编译型语言是代码在运行前编译器将人类可以理解的语言（编程语言）转换成机器可以理解的语言；</li>
<li>解释型语言也是人类可以理解的语言（编程语言），也需要转换成机器可以理解的语言才能执行，但是是在运行时转换的。所以执行前需要解释器安装在环境中</li>
<li>解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。</li>
<li>可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现</li>
<li>编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化</li>
</ul>
<h4 id="JIT（Just-In-Time）即时编译代码优化"><a href="#JIT（Just-In-Time）即时编译代码优化" class="headerlink" title="JIT（Just In Time）即时编译代码优化"></a>JIT（Just In Time）即时编译代码优化</h4><p>解释型语言的特点导致其先天性运行缓慢，为了解决其效率问题后来的浏览器引入了编译器，和解释器配合来优化运行速度。  </p>
<ul>
<li><strong>基线编译器：</strong> JavaScript引擎中增加一个监视器（也叫分析器），起初监听器监视所有通过解释器的代码，如果一行代码运行了几次，则被标记为“warm”，如果运行了多次，则被标记为“hot”。如果一段代码变成了 “warm”，那么 JIT 就把它送到编译器去编译，并且把编译结果存储起来；如果一个代码段变得 “very hot”，监视器会把它发送到优化编译器中，生成一个更快速和高效的代码版本出来，并且存储之。</li>
<li><strong>优化编译器：</strong> JS是一门动态类型的语言，但要让JS运行时变快，就要尽量在运行时作为静态类型的语言来处理。因此优化编译器必须做一些假设，在这条线索执行过程中，相关的字节码实际上可以理解为已经替换为类型化的字节码，当所有的实例都有相同的属性名，并且都以同样的顺序初始化，那么就可以针对这一模式进行优化，所以编译代码需要在运行之前检查其假设是不是合理的。如果合理，那么优化的编译代码会运行，如果不合理，那么 JIT 会认为做了一个错误的假设，并且把优化代码丢掉。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function arraySum(arr) &#123;</span><br><span class="line">    var sum = 0; </span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中arr数组的内容的类型不确定，故sum的类型是不确定的，假设arr第50个元素是String类型，其它元素都是int类型，假设当此循环执行10次后，被标记为very hot，优化编译器首先假设i是int，arr.length是int，sum是int，那后面11到49都满足次假设，会用优化编译器去做优化，即后续执行不需要解释器去解释此段代码，而是直接加载编译好的二进制码，故而提高效率；但到第50次时，因为arr[49]是String，前面的假设是错误的，故丢弃次优化。第51次运行时再次解释器，基线编译器，直到其符合优化编译器要求才会再次被编译优化。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;JIT要解决的问题是减少代码的重复解释来提高效率，但即时编译本身也是会影响运行效率的，因此准确的定位高频代码并适量的去编译方可以达到最佳优化状态。</p>
<h3 id="V8优化"><a href="#V8优化" class="headerlink" title="V8优化"></a>V8优化</h3><p>V8是Google的除了引入JIT，还做了其他优化  </p>
<h5 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h5><p>第一个优化是提前尽可能多地内联代码。内联是将被调用函数的主体替换为调用站点（调用函数的代码行）的过程。这个简单的步骤使得下面的优化更有意义，如下图，将一段代码分为多个函数调用，可以尽可能的加大内联优化的可能性。<br><img src="http://p9jmdxlv0.bkt.clouddn.com/1527686584744.jpg" alt=""></p>
<h5 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h5><ul>
<li>V8在内部为对象创建隐藏类(类似于Java的类，不同的是在运行时创建，且可动态改变)</li>
<li>具有相同隐藏类的对象可以使用相同的优化代码</li>
<li>每当一个新的属性被添加到一个对象时，旧的隐藏类将被更新为到新的隐藏类的转换路径</li>
<li>隐藏类转换取决于将属性添加到对象的顺序。看看下面的代码片段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x,y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Point(1, 2);//此时v8引擎为p1创建了一个隐藏类，假设为X</span><br><span class="line">p1.a = 5;//因为p1插入了新属性，故p1的隐藏类改变为Y</span><br><span class="line">p1.b = 6;//因为p1插入了新属性，故p1的隐藏类改变为Z</span><br><span class="line">var p2 = new Point(3, 4);//因p2的属性和属性顺序和p1创建时一样，故此时p2的隐藏类改变为X</span><br><span class="line">p2.b = 7;//因为p2插入了新属性，故p1的隐藏类改变为M，M不同于Y</span><br><span class="line">p2.a = 8;//因为p1插入了新属性，故p1的隐藏类改变为N，N不同于Z</span><br></pre></td></tr></table></figure>
<h5 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h5><ul>
<li>V8 利用另一种被称为内联缓存的技术来优化动态类型语言。内联缓存依赖于发生在相同类型的对象上的相同方法的重复调用的观察上。</li>
<li>V8 维护一个在最近的方法调用中作为参数传递的对象类型的缓存，并使用这些信息来预测将来作为参数传递的对象的类型。如果V8能够很好地假定传递给方法的对象类型，那么它可以绕过如何访问对象的属性的过程，而是将之前查找到的信息用于对象的隐藏类。</li>
<li>V8 引擎都必须执行对该对象的隐藏类的查找，以确定访问特定属性的偏移量。在同一个隐藏类的两次成功的调用之后，V8 省略了隐藏类的查找，并简单地将该属性的偏移量添加到对象指针本身。（通过隐藏对象确定对象访址偏移）</li>
<li>内联缓存也是为什么相同类型的对象可以共享隐藏类非常重要的原因。如果你创建了两个相同类型的对象和不同的隐藏类，V8 将不能使用内联缓存，因为即使两个对象是相同的类型，它们相应的隐藏类为其属性分配不同的偏移量。</li>
</ul>
<h3 id="3-JavaScript——函数式编程"><a href="#3-JavaScript——函数式编程" class="headerlink" title="3. JavaScript——函数式编程"></a>3. JavaScript——函数式编程</h3><h4 id="函数式编程vs命令式编程"><a href="#函数式编程vs命令式编程" class="headerlink" title="函数式编程vs命令式编程"></a>函数式编程vs命令式编程</h4><ul>
<li>函数式编程关心类型（代数结构）之间的关系，命令式编程关心解决问题的步骤</li>
<li>函数式编程的准则：函数式编程强调程序的执行结果，函数不受外部变量影响，不依赖于外部变量，也不改变外部变量的值  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 命令式</span><br><span class="line">var a = 1 + 2;</span><br><span class="line">var b = a * 3;</span><br><span class="line">var c = b - 4;</span><br><span class="line"></span><br><span class="line">// 函数式</span><br><span class="line">var result = subtract(multiply(add(1,2), 3), 4);</span><br></pre></td></tr></table></figure>
<h4 id="函数式编程特征"><a href="#函数式编程特征" class="headerlink" title="函数式编程特征"></a>函数式编程特征</h4><ul>
<li>数据不可变性(immutable data)  变量只可以赋值一次，变量不可变，如果想改变变量就创建一个新的变量。</li>
<li>函数是第一公民(first class method)  函数可以像普通变量一样去使用。函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数</li>
<li>引用透明(referential transparency)  指的是函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数，任何时候只要参数相同，调用函数所得到的返回值总是相同的。天然适应并发编程，因为调用函数的结果具有一致性，所以根本不需要加锁，也就不存在死锁的问题</li>
<li>尾递归化（tail call optimization）<br>因为函数调用要压栈保存现场，递归层次过深的话，压栈过多会产生性能问题。所以引入尾递归优化，每次递归时都会重用栈，提升性能</li>
</ul>
<h4 id="JavaScript与函数式语言关系"><a href="#JavaScript与函数式语言关系" class="headerlink" title="JavaScript与函数式语言关系"></a>JavaScript与函数式语言关系</h4><ul>
<li><p>Javascript的词法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。 这些特点对构成函数式编程的结构和行为至关重要</p>
</li>
<li><p>Javascript是一个解释型语言，因此Javascript的确也不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用</p>
</li>
</ul>
<h3 id="4-原型对象及原型链"><a href="#4-原型对象及原型链" class="headerlink" title="4. 原型对象及原型链"></a>4. 原型对象及原型链</h3><h4 id="JavaScript类型"><a href="#JavaScript类型" class="headerlink" title="JavaScript类型"></a>JavaScript类型</h4><ul>
<li>原始值<br>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。Undefined、Null、Boolean、Number和String</li>
<li>引用值<br>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</li>
<li>对象类型又分为<br>本地对象(Object，Function， Array，String，Boolean，Error…)<br>内置对象(Global 和 Math)<br>宿主对象(DOM, process)  </li>
</ul>
<h4 id="函数和对象关系"><a href="#函数和对象关系" class="headerlink" title="函数和对象关系"></a>函数和对象关系</h4><ul>
<li>JavaScript一切皆对象（除原始类型外）</li>
<li>函数也是对象，一个函数是一个Funciton对象</li>
<li>所有对象都直接或者间接”继承”于Object</li>
<li>对象都是通过函数创建的(包括对象字面量)</li>
<li>Object是一种函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">console.log(fn instanceof Function)//true</span><br><span class="line">console.log(obj instanceof Object)//true</span><br><span class="line">console.log(fn instanceof Object)//true</span><br><span class="line">console.log(obj instanceof Function)//false</span><br><span class="line">console.log(Function instanceof Object); // true</span><br><span class="line">console.log(Object instanceof Function); // true</span><br></pre></td></tr></table></figure>
<h4 id="函数原型对象"><a href="#函数原型对象" class="headerlink" title="函数原型对象"></a>函数原型对象</h4><p>定义：在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 prototype 指向了这个对象( 即：prototype的属性的值是这个对象 )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p9jmdxlv0.bkt.clouddn.com/2.jpg" alt=""></p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p><img src="http://p9jmdxlv0.bkt.clouddn.com/4.jpg" alt=""></p>
<h3 id="5-JavaScript-面向对象"><a href="#5-JavaScript-面向对象" class="headerlink" title="5. JavaScript 面向对象"></a>5. JavaScript 面向对象</h3><p>一种面向对象语言需要向开发者提供四种基本能力：<br>抽象 - 提取接口能力<br>封装 - 把相关的信息（无论数据或方法）存储在对象中的能力<br>继承 - 由另一个类（或多个类）得来类的属性和方法的能力<br>多态 - 编写能以多种方法运行的函数或方法的能力<br>ECMAScript 号称是面向对象的，我们来看看它是怎么一步步实现面向对象的。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>类 {属性 + 方法}，几乎所有语言都可以做到这一点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, sex) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">       this.sex = sex;</span><br><span class="line">	       this.say = function() &#123;</span><br><span class="line">             alert(“我的名字是”+this.name);</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####继承<br>下面介绍JavaScript几种继承实现方式  </p>
<ul>
<li>对象冒充<br>通过在本函数作用域调用另一个函数的构造方法达到将该函数的属性和方法引入到本函数，实现如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.sayColor = function () &#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ClassB继承ClassA</span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    this.newMethod = ClassA;</span><br><span class="line">    this.newMethod(sColor);</span><br><span class="line">    delete this.newMethod;</span><br><span class="line"></span><br><span class="line">    this.name = sName;</span><br><span class="line">    this.sayName = function () &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多继承 ClassZ继承ClassA和ClassB</span><br><span class="line">function ClassZ() &#123;</span><br><span class="line">    this.newMethod = ClassX;</span><br><span class="line">    this.newMethod();</span><br><span class="line">    delete this.newMethod;</span><br><span class="line"></span><br><span class="line">    this.newMethod = ClassY;</span><br><span class="line">    this.newMethod();</span><br><span class="line">    delete this.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原型链实现继承</li>
</ul>
<p>每个类的构造函数都指向一个原型对象（ prototype ），prototype 对象是个模板，要实例化的对象都以这个模板为基础， prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ClassA() &#123;</span><br><span class="line">&#125;</span><br><span class="line">ClassA.prototype.color = &quot;blue&quot;;</span><br><span class="line">ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;;</span><br><span class="line">function ClassB() &#123;</span><br><span class="line">&#125;</span><br><span class="line">ClassB.prototype = new ClassA(); // ClassB继承ClassA</span><br></pre></td></tr></table></figure>
<ul>
<li>混合方式实现继承<br>对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。<br>创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function ClassA(sColor) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">&#125;</span><br><span class="line">ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;;</span><br><span class="line">function ClassB(sColor, sName) &#123;</span><br><span class="line">    ClassA.call(this, sColor);</span><br><span class="line">    this.name = sName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = new ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.sayName = function () &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用extends关键字<br>为了使JavaScript更加面向对象，ES6强行加入了class，extends的关键字，class关键字是语法糖，本质还是函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Polygon &#123;</span><br><span class="line">   constructor(height, width) &#123;</span><br><span class="line">       this.name = &apos;Polygon&apos;;</span><br><span class="line">       this.height = height;</span><br><span class="line">       this.width = width;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Square extends Polygon &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">      super(length, length);</span><br><span class="line">      this.name = &apos;Square&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class原理"><a href="#class原理" class="headerlink" title="class原理"></a>class原理</h4><p>下面我们来了解Es6 class的原理，先看如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">  constructor(name,age)&#123;</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.age = age&#125;</span><br><span class="line">  static see()&#123;alert(&quot;how are you&quot;)&#125;  &#125;</span><br><span class="line">  say()&#123;console.log(&quot;hello&quot;);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码本质上：<br>People是一个类，也是一个函数；<br>constructor是一个对象指向的是People函数，该函数还挂了name和age属性；<br>将see函数挂载到People的原型上；<br>将say函数挂载到People函数上。 </p>
<p>故如上代码等价于如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let People = function()&#123; //第①步，创建People函数</span><br><span class="line"> </span><br><span class="line"> function People(name,age)&#123;//第②步，理解constructor就是指向People，People挂载着name和age两个属性</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;&#125;</span><br><span class="line">   </span><br><span class="line"> //将静态和动态的方法分别挂载在People的原型和People上。   </span><br><span class="line"> creatClass(People,[&#123;key:&quot;say&quot;,value:function()&#123;</span><br><span class="line">     console.log(123)&#125;&#125;],[&#123;key:&quot;see&quot;,value:function()&#123;</span><br><span class="line">     alert(&quot;how are you&quot;)&#125;&#125;])  </span><br><span class="line">     </span><br><span class="line"> return People;&#125;</span><br><span class="line"> </span><br><span class="line">//这里的Constructor就是指的People  </span><br><span class="line">let creatClass = function(&#123;</span><br><span class="line">  return function(Constructor,,protoProps,staticProps)&#123;</span><br><span class="line">     //有原型上的方法挂载People.prototype上</span><br><span class="line">     if(protoProps)&#123;defineProperties(Constructor.prototype,protoProps)&#125;</span><br><span class="line">      //有People对象上的方法挂载People上</span><br><span class="line">     if(staticProps)&#123;defineProperties(Constructor,staticProps)&#125;&#125;</span><br><span class="line"> </span><br><span class="line">//定义对象属性     </span><br><span class="line">let defineProperties =function(target, props) &#123;</span><br><span class="line">     for (var i = 0; i &lt; props.length; i++) &#123;</span><br><span class="line">       var descriptor = props[i];</span><br><span class="line">       Object.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上是作为初学者的我总结的JavaScript的几个基本面，希望对各位初学者有所帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/Javascript first getting/" data-id="cjhulgd3v0005t5ui4hmefwfh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/特性/">特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AliStudio normal keymap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/AliStudio normal keymap/" class="article-date">
  <time datetime="2018-05-10T06:14:39.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/YunOS学习/">YunOS学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/AliStudio normal keymap/">Alistudio常用快捷键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="已下是我整理的Alistudio常用快捷键说明，希望对各位初学Alistudio的朋友有帮助"><a href="#已下是我整理的Alistudio常用快捷键说明，希望对各位初学Alistudio的朋友有帮助" class="headerlink" title="已下是我整理的Alistudio常用快捷键说明，希望对各位初学Alistudio的朋友有帮助"></a>已下是我整理的Alistudio常用快捷键说明，希望对各位初学Alistudio的朋友有帮助</h3><p>ctrl-t    查找文件<br>ctrl-p    查找文件<br>ctrl-b    在已打开的文件中查找文件<br>ctrl-r    查找函数和变量<br>ctrl-d    查找下一个<br>ctrl-down    整行下移<br>ctrl-up    整行上移<br>ctrl-f    当前文件查找<br>ctrl-enter    确认（查找，替换，提交）<br>ctrl-f4    关闭item（同ctrl-w）<br>ctrl-o    toggle Structure View<br>ctrl-g    跳到某一行<br>ctrl-l    选择行<br>ctrl-m    移动到括符的另一端<br>ctrl-n    新建文件<br>ctrl-w    关闭item<br>ctrl-pagedown    切换到上一页（item）<br>ctrl-pagedown    切换到下一页（item）<br>ctrl-Alt-,    选中当前括符内容<br>ctrl-alt-/<br>ctrl-alt-[    “折叠所有Tree view<br>折叠方法或者类{}”<br>ctrl-alt-]    “展开所有Tree view<br>展开方法或者类{}”<br>ctrl-alt-b    自动对齐<br>ctrl-alt-c    重命名<br>ctrl-alt-up    光标纵向选择<br>ctrl-alt-down    光标纵向选择<br>ctrl-alt-f2    添加书签<br>ctrl-f2    查看书签<br>ctrl-f3    查找下一个<br>ctrl-alt-right    跳到下一个编辑点，通常是函数或循环末尾<br>ctrl-alt-left    跳到上一个编辑点<br>ctrl-alt-p    toggle toolsbar<br>ctrl-alt-shift-[    折叠全部方法或者类{}<br>ctrl-alt-shift-]    展开全部方法或者类{}<br>ctrl-alt-space    代码提示<br>ctrl-shift-c    copy当前文件的路径<br>ctrl-shift-d    复制并插入一行<br>ctrl-shift-f    全局查找<br>ctrl-shift-i    toggle dev tools<br>ctrl-shift-k    删除一行<br>ctrl-shift-U    编码选择<br>ctrl-shift-W    关闭Window<br>ctrl-shift-enter    在上面插入一行<br>ctrl-shift-f3    查找上一个<br>ctrl-shift-tab    切换已打开的item</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/10/AliStudio normal keymap/" data-id="cjhulgd3h0000t5uiqappc2tf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Alistudio/">Alistudio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YunOS/">YunOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Alios SettingsProvider" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/Alios SettingsProvider/" class="article-date">
  <time datetime="2018-05-10T06:14:39.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/YunOS学习/">YunOS学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/Alios SettingsProvider/">Alios SettingsProvider模块学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-SettingsProvider目录结构"><a href="#1-SettingsProvider目录结构" class="headerlink" title="1. SettingsProvider目录结构"></a>1. SettingsProvider目录结构</h3><p><a href="http://cloudapp.yunos.com/#/%2Fdevelop%2Fopen%2Fuserguide%2Fdownload?level=1" target="_blank" rel="noopener">http://cloudapp.yunos.com/#/%2Fdevelop%2Fopen%2Fuserguide%2Fdownload?level=1</a><br><img src="http://p6yo9m4e0.bkt.clouddn.com/YunOS-Code1.png" alt="class picture"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/10/Alios SettingsProvider/" data-id="cjhulgd3l0001t5uibtptj872" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Settings/">Settings</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SettingsProvider/">SettingsProvider</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YunOS/">YunOS</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript学习/">Javascript学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/YunOS学习/">YunOS学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Alios/">Alios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Alistudio/">Alistudio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PageIPC/">PageIPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Settings/">Settings</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SettingsProvider/">SettingsProvider</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YunOS/">YunOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getRunningPages/">getRunningPages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础/">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/特性/">特性</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Alios/" style="font-size: 10px;">Alios</a> <a href="/tags/Alistudio/" style="font-size: 10px;">Alistudio</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/PageIPC/" style="font-size: 10px;">PageIPC</a> <a href="/tags/Settings/" style="font-size: 10px;">Settings</a> <a href="/tags/SettingsProvider/" style="font-size: 10px;">SettingsProvider</a> <a href="/tags/YunOS/" style="font-size: 20px;">YunOS</a> <a href="/tags/getRunningPages/" style="font-size: 10px;">getRunningPages</a> <a href="/tags/基础/" style="font-size: 10px;">基础</a> <a href="/tags/特性/" style="font-size: 10px;">特性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/18/Alios PageIPC/">Alios PageIPC getRunningPages源码分析</a>
          </li>
        
          <li>
            <a href="/2018/05/18/Javascript first getting/">Javascript基础认知</a>
          </li>
        
          <li>
            <a href="/2018/05/10/AliStudio normal keymap/">Alistudio常用快捷键</a>
          </li>
        
          <li>
            <a href="/2018/05/10/Alios SettingsProvider/">Alios SettingsProvider模块学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>